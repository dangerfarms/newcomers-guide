# Unit Testing

This article focuses on unit testing in general. Examples are written for a Django backend service.

Developers write tests to prove that *under certain conditions* their code will perform as expected. In writing tests a developer does not try to prove their code is correct - the tested parts of the code are not mathematical theorems. Instead, with enough representative examples, they might ensure if code contains errors they will be found by one or more tests.

It is for this reason **a test suite should contain many, small tests**, where each test proves one specific thing only. These tests are heuristics, not proofs.

With all that in mind, a good test should be:

- readable 
- deterministic
- fast
- well designed.

### Readable Tests

Tests not only provide the programmer with a degree of certainty that their code works, but also serve as documentation. The ideal mindset when writing tests is to imagine that you are looking at the project's code for the first time, you would want each test to tell a story.

```python
def test_should_disable_logged_in_user_if_active(self):
    """Test API sets User.disabled = True. Refetch from database to prove."""
    user = self.create_user()
    self.login(user)
    response = self.client.post(self.disable_url)
    db_user = self.fetch_db_user(user.id)
    self.assertTrue(db_user.disabled)
```

The above test is very easy to follow:
- The method name states what it is testing
- Every variable has a descriptive name
- More complex behaviour is abstracted away to methods

Test method names should describe an expected result from the **system under test** given a particular state, i.e. `should_do_something_if/when_something_else`. Note: the above test prepends test_ to tell the test runner that it is a test to be executed and should be ignored when reading test names.

The rule of writing descriptive names should not just apply to test code, but to the entire project. Having a variable named `a` in any file is not helpful for someone not familiar with the codebase. In fact, you should always strive for the most readable code, and it is arguably most important in tests.

Due to the importance of readability, tests are the only place in code where we feel [DRY](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself)ness is not always the right approach.  

However if extracting common behaviour can be done in a way to let a test story flow, then it is preferred to do so. For example in the line `self.login(user)` from above a common behaviour (logging a user in) has been abstracted away to a base class containing similar helper functions.  

This is a win-win: it makes the test more readable and more DRY at the same time. (The line was originally `self.client.login(username=user.username, password=USER_PASSWORD)`.)

To summarize: if you can make a test both more readable and DRYer then 100% do so, otherwise aim for readability.

### Deterministic Tests

Writing deterministic tests normally comes down to one evil: controlling data.

One example is testing against dates/times. When doing something like `datetime.today()`, you are playing with fire unless you are very careful with data arrangements and assertions. On top of that, relying on a specific day means you can't really test for edge cases e.g. 29th February. 

The solution for the problem of controlling data is to use **mock objects**.

Mocks allow you to program parts of your application with pre-defined behaviour/data, so you can run your test many times within the same controlled environment.

```python
@mock.patch('some.app.models.timezone')
def test_should_set_the_expiry_date(self, mock_timezone):
    now =  timezone.make_aware(timezone.datetime(2016, 1, 1))
    mock_timezone.now.return_value = now
    expected_expiry_date = now + timedelta(days=1)
    token = Token.objects.create()
    self.assertEqual(token.expiry_date, expected_expiry_date)
```

In the above example instead of relying on the actual value of `timezone.now()`, which we cannot control, we tell the test to override that `timezone` module with a mock module, that always returns the 2016-01-01.

On the flip side, we want to _avoid_ hardcoded values in case we are interacting with objects that are generated by the tested part of our code, for example models.
A common pitfall is using hardcoded primary keys for filtering for objects in the test.

```python
def test_id_bad(self):
    user = User.objects.create()
    update_user(user)
    # Refetch user from DB to show changes have saved
    # Bad, cannot assume ID is 1
    user_from_db = User.objects.get(id=1)
    self.assertEqual(user_from_db.field, 'updated')

def test_id_good(self):
    user = User.objects.create()
    update_user(user)
    # Refetch user from DB to show changes have saved
    # Good, makes no assumptions about the User's id
    user_from_db = User.objects.get(id=user.id)
    self.assertEqual(user_from_db.field, 'updated')
```

The bad test might run on your system for the first time, but it might fail the second time or might fail on someone else's system, depending on the state (and kind) of the database backend that is used for the tests.

### Fast Tests

Tests should be fast for obvious reasons - nobody wants to wait around for an hour while they prove the one line of code the changed didn't break the entire system.

There are a couple of things you can do to ensure they can be as fast as possible.

##### Don't create more test data than you need to

To prove correctness for your specific test, how many objects do you really need to create? 

If you are proving that a maximum of 2 objects are returned from a list, then add 3. 

Adding more data than necessary to prove a specific case is pointless and slows down the system.

(This ties into the much broader point that you should be able to reason about every line of code to write. More on that another time.)

##### Creating data in `setUp`

Creating data in `setUp` methods is a common way to fall into the trap of creating more data than you need.

Imagine your `setUp` method creates 5 objects, and 4 of your tests don't actually use the data. This means 20 pointless DB writes happen every time we run the test suite. This can add up, and has a bad impact on speed that can be difficult to spot.

It's usually better to explicitly set up the data needed in each test, even if this contradicts DRY. It will make the tests more readable anyway, and makes you think harder about how to keep them lean.

If you truly do have the exact same set of objects created for many tests, move the repeated code to a method, and call it explicitly in each test (**not** in `setUp`).

If you truly need all of the data for every test in a class, then of course it is fine to create it in `setUp`.

##### Mock out "slow" interfaces

In unit testing, slow running parts of a system tend to involve network requests such as external API calls or file transfers. Not only are these slow, but they can be non-deterministic, if for instance, an external service is down. Unit testing is about testing **your** code, and for many reasons, mocking should almost always be done for any kind of stream handling or external service.

(Note that the goal of _integration tests_ is to test two or more parts of the app working together. There is no guarantee that an external service won't change their API unexpectedly, and should find that out before deploying the application. For development purposes however unit tests should be run more often to allow for better development speed.)

### Correct Tests

A correct test is one which tests what it should be testing - very meta :-)

Or, to put it in another way, a correct test is a test in which the initial state and final assertions can provide a high enough certainty that the code works, relative to the contract of the test name.

In short:

- Have meaningful test names
- Create an initial state which can help to prove assertions
- Be sure to make specific assertions which can prove your test

Let's show some examples:

```python
def test_should_return_no_users_if_hide_is_True(self):
    """
    **BAD**
    Here we are not proving that hide has any effect on the implementation
    because we have not created any users. The initial state of the system
    provides a false positive. 

    A good developer would make sure to also add another test proving users
    are returned if hide=False, so as to further negate other false assumptions.
    """
    users = service.get_users(hide=True)
    self.assertEqual(users.count(), 0)

def test_should_update_user_when_endpoint_PATCHed(self):
    """
    **BAD**
    Here we are arranging the initial data correctly, but our assertions are too
    weak. The tests says SHOULD UPDATE therefore proving the response comes back
    is not enough.

    See the next example for additional improvements.
    """
    user = User.objects.create()
    patch_data = {
        "password": "secure"
    }
    self.login(user)
    response = self.client.PATCH(self.url, patch_data)
    self.assertEqual(response.status_code, status.HTTP_200_OK)

def test_should_update_user_when_endpoint_PATCHed(self):
    """
    **BETTER**
    Now we add in a few subtle assertions that give us higher certainty
    that our code is correct.
    """
    user = User.objects.create()
    # After creating the user, prove their password is not already secure
    # as if our implementation just did nothing, this test would still pass
    self.assertFalse(user.check_password('secure'))
    patch_data = {
        "password": "secure"
    }
    self.login(user)
    response = self.client.PATCH(self.url, patch_data)
    self.assertEqual(response.status_code, status.HTTP_200_OK)
    # After the status_code assertion, we need to prove the User has been
    # updated.
    db_user = User.objects.get(id=user.id)
    self.assertTrue(db_user.check_password('secure'))

def test_should_showcase_a_good_way_to_test(self):
    """
    This test shows a good pattern to follow that helps in creating your tests
    by following the Arrange/Act/Assert method.

    The steps involve:
    1. Arrange your test data (as well as make assertions if necessary)
    2. Act on your system under test
    3. Assert the system is in the correct state after executing
    """
    # Arrange
    user = User.objects.create()
    self.assertEqual(user.username, 'user')
    self.login(user) # IMO belongs in Arrange as stateful

    # Act
    response = service.call(user)

    # Assert
    self.assertEqual(response.data, "something specific")

```

As said previously, creating many small, specific tests is a great way to focus effort and produce tests that are effective. Test Driven Development also helps by thinking about one test at a time.